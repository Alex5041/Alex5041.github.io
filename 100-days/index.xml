<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>100-days on</title><link>https://alex5041.github.io/100-days/</link><description>Recent content in 100-days on</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://alex5041.github.io/100-days/index.xml" rel="self" type="application/rss+xml"/><item><title>100 writing days</title><link>https://alex5041.github.io/100-days/100-writing-days/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://alex5041.github.io/100-days/100-writing-days/</guid><description>Previously I did 100 reading days, but looking back, I think It was mostly about achieving consistency rather than improving pronunciation.</description></item><item><title>Abstract Syntax Tree</title><link>https://alex5041.github.io/100-days/ast/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://alex5041.github.io/100-days/ast/</guid><description>Abstract Syntax Tree (AST) is key concept in program evaluation. It is a tree with tokens as its nodes. Tree is a better structure than sequence.</description></item><item><title>Basic memory management</title><link>https://alex5041.github.io/100-days/heap-and-stack/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://alex5041.github.io/100-days/heap-and-stack/</guid><description>Last fall, I had an interview. They asked me about differences between heap and stack, how references and variables are stored.</description></item><item><title>C#: Boxing, unboxing and equality operator</title><link>https://alex5041.github.io/100-days/boxing-and-equality-cs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://alex5041.github.io/100-days/boxing-and-equality-cs/</guid><description>Boxing / unboxing Boxing/unboxing has to do with reference and value types. Value types store their values on stack (usually primitives).</description></item><item><title>C++ Memory model</title><link>https://alex5041.github.io/100-days/cpp-pointers/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://alex5041.github.io/100-days/cpp-pointers/</guid><description>Memory is a two column table. First row contains addresses, second row contains values.
1 int x = 4; When variable is assigned, an empty memory row cell is chosen.</description></item><item><title>Devlog 1. Bad globals</title><link>https://alex5041.github.io/100-days/devlog1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://alex5041.github.io/100-days/devlog1/</guid><description>What is a symbol table? Symbol table stores current program state. I separated it into three levels, turning SymbolTable into a kind of manager-facade:</description></item><item><title>Devlog 2. Link class. Removing state</title><link>https://alex5041.github.io/100-days/devlog2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://alex5041.github.io/100-days/devlog2/</guid><description>Link class is for evaluating links. A link is a statement in form of a.b.c, where all expressions after dots (in this case b and c) are either identifiers1, indexes2 or invocations3.</description></item><item><title>How languages are run?</title><link>https://alex5041.github.io/100-days/transpilers-compilers-interpreters/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://alex5041.github.io/100-days/transpilers-compilers-interpreters/</guid><description>People in the programing languages field use fancy buzzwords like translator, transpiler, compiler, interpreter, JIT (just in time) compiler. Let&amp;rsquo;s figure out what they mean.</description></item><item><title>Introduction to grammars</title><link>https://alex5041.github.io/100-days/introduction-to-grammars/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://alex5041.github.io/100-days/introduction-to-grammars/</guid><description>Grammar defines a set of strings (words), which is called a language. Essentially grammar is a Dictionary &amp;lt;String, String&amp;gt;, where each dictionary entry is a grammar rule.</description></item><item><title>Multithreading. Primitive tools, definitions</title><link>https://alex5041.github.io/100-days/multithreading1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://alex5041.github.io/100-days/multithreading1/</guid><description>First, let&amp;rsquo;s clarify some definitions (I won&amp;rsquo;t go too deep into that):
Process Process is a running program, that has its own address space in memory (most of it is heap).</description></item><item><title>Multithreading. Problems, Object methods</title><link>https://alex5041.github.io/100-days/multithreading2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://alex5041.github.io/100-days/multithreading2/</guid><description>Thread problems Thread problems have names. Here are the most popular ones.
Deadlock N locks locked forever, waiting for each other.</description></item><item><title>Parsers</title><link>https://alex5041.github.io/100-days/parsers/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://alex5041.github.io/100-days/parsers/</guid><description>As with the first article, I wrote this one on a computer, because the topic is hard to tackle. I knew I would have to make a lot of edits and rearrangements.</description></item><item><title>Shallow villain traits</title><link>https://alex5041.github.io/100-days/shallow-villain-traits/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://alex5041.github.io/100-days/shallow-villain-traits/</guid><description/></item></channel></rss>