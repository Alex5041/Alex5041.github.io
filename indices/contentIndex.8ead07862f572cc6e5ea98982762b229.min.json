{"/":{"title":"WaterStop","content":"\n\n[ReGIna](regina/regina)\n\n[Insta](regina/dynamic-instantiation.md)\n\n[Other notes](notes/eyes)\n\n$$a = 2$$","lastmodified":"2022-06-05T21:40:05.216713561Z","tags":null},"/Assignment":{"title":"","content":"# Assignment\nLeft side of the assignment before `=` is lvalue, right side is rvalue\n## Lvalue\nThere are 4 types of possible lvalues\n### Variable\n\n### Property\nSimilar to variables, however their scope is class or primitive.\n### Indexing\nChanging array's  element is possible with `arr[i] = ...`\n### Reference","lastmodified":"2022-06-05T21:40:05.216713561Z","tags":null},"/notes/eyes":{"title":"Eyes","content":"","lastmodified":"2022-06-05T21:40:05.216713561Z","tags":null},"/regina/dynamic-instantiation":{"title":"","content":"# Dynamic instantiation\n\nClasses can have references to other classes inside them as\nproperties. These property-classes are evaluated dynamically. Take a look at this example:\n\n```kotlin\nclass Node export rect {\n    // export = false - can deny export\n    iter = if (parent) parent.iter + 1 else 0\n\n    childNode = if (iter == 5) Nothing() else Node()\n\n    position = if (childNode is Node) \\\n    Position(childNode.position.x + 1, childNode.position.y) \\\n    else Position(0, 0)\n}\n\nfun main() {\n    Node()\n}\n```\n\nThis will create following svg:\n\n```svg\n\n\u003csvg\u003e\n    \u003crect x=\"4\" y=\"0\"/\u003e\n    \u003crect x=\"3\" y=\"0\"/\u003e\n    \u003crect x=\"2\" y=\"0\"/\u003e\n    \u003crect x=\"1\" y=\"0\"/\u003e\n    \u003crect x=\"0\" y=\"0\"/\u003e\n\u003c/svg\u003e\n```\n\nFirst algorithm creates empty Node() (we'll call it *Node0*) from main(). Then, starting from top to bottom:\n\n1. algorithm assigns **iter** of *Node0* to 0 because parent returns 0 as an equivalent of null.\n2. After that, **childNode** is assigned a new Node (*Node1*).\n3. **position** cannot be assigned because **childNode.position** is not yet assigned. Algorithm goes to\n   childNode.position, that is *Node1*.position and tries to assign it. However, childNode is required, so we go to *\n   Node1*.childNode, which needs iter.\n\n*It's not important to consider while assigning values, but it shows why there cannot be any cyclic dependencies for\nproperties*.\n\n## Implied decision\n\nAlso, it is the reason why class functions are impossible. Imagine this case:\n\n```kotlin\nclass FunctionOveruse {\n    prop = make()\n\n    fun make() {\n        FunctionOveruse()\n        return prop\n    }\n}\n```\n\nBoth lines in ```make()``` will execute forever.\n\nTo make functions as expressive as possible, it is important to allow class instantiating inside them. If\n\nWe either make internal class functions (which is purely decompositional thing) or make instantiating inside functions\npossible (and ```fun main()``` as an entry point)","lastmodified":"2022-06-05T21:40:05.216713561Z","tags":null},"/regina/regina":{"title":"ReGIna","content":"\nis a [dynamically typed](notes/typization.md) language with [syntax](syntax.md) similar to Kotlin\nand Python.\n[files](../regina-files.json)\n\n## Core idea\n\nDifference between other languages and ReGIna is [dynamic instantiation](regina/notes/dynamic-instantiation.md). In\nshort, properties in classes will be assigned only after their dependencies are assigned, allowing recursive properties\nof same class `A` inside class `A`.\n\n## Advantages\n\n* **Can be embedded into web**. Regina is written in Kotlin and compiled into Javascript.\n* **Rapid generator development**. Look at [examples](#Examples) to see what can be done and how much code is required.\n* **Customizable export**.\n\n## Drawbacks\n\n* **It's slow**. It's definitely slower than Python. Yet it's designed to be fast and concise in creating generators.\n    * **There is no community**. At least not yet. Mail me at kononal@gmail.com if you created something about Regina.\n\n## Examples\n","lastmodified":"2022-06-05T21:40:05.22071359Z","tags":null},"/regina/syntax":{"title":"","content":"# Syntax\n\nReGIna's syntax is an amalgamation of kotlin and python.\n\n## Declarations\n```python\nfrom typing import Iterator\n\n# This is an example\nclass Math:\n    @staticmethod\n    def fib(n: int) -\u003e Iterator[int]:\n        \"\"\" Fibonacci series up to n \"\"\"\n        a, b = 0, 1\n        while a \u003c n:\n            yield a\n            a, b = b, a + b\n\nresult = sum(Math.fib(42))\nprint(\"The answer is {}\".format(result))\n```\n### Class\n\nClass declaration should satisfy following format:\n\n```kotlin \nclass ClassName : SuperClassName export circle {\n    ...\n}\n```\n\nwhere `: SuperClassName` and `export ...` are optional.\n\n### Object\n\n```kotlin\nobject ObjectName export circle {\n    ...\n}\n```\n\nSimilar to type, although it cannot be inherited.\n\n### Function\n\n```kotlin\nfun functionName(arg0, arg1, ...) {\n    ...\n}\n```\n\n### Property/variable assignment\n\n```kotlin\nvariableName = ...\nclassName.PropertyName = ...\n```\n\nVariables and properties are dynamic, meaning they are type independent. `a` can be String and in the next line it can\nbe Int or class instance.\n\n## References\n\nReferences are expressions of form `a.b.c`. They serve 3 purposes:\n\n1. accessing class/object properties\n2. accessing primitive/class/object and functions\n3. specifying package declarations\n4. reducing expressions\n\n### 1. Accessing properties\n\n\n# Code conventions\n\nCamel case is used.\n\nNames of [class](Syntax.md/###Class), [object](Syntax.md/###Object) start with capital.\n\nVariables, functions start with lowercase letter.","lastmodified":"2022-06-05T21:40:05.22071359Z","tags":null},"/regina/typization":{"title":"","content":"Dynamically typed languages check variable type during runtime, meaning it is more **error-prone**.On the contrary,\nstatically typed languages check variable type during compilation.\n\nOften dynamically typed languages can reassign the same variable with a different type. Also, variable declaration and\nassignment are similar for dynamic languages.\n\n```Python\n# Python\na = 2\na = \"2\" # not an error\n```\n\nOne of the clues of static typing is in variable declaration:\nusually variables have a type before a name in declaration:\n\n```C\n // C\n int a = 2;\n a = 3;\n```\n\nHowever, it is not always the case:\n\n```Kotlin\n// Kotlin\nval a = 2\n```\n\nIn Kotlin variable declaration prefix determines its mutability and type is derived from the expression on the right.\n","lastmodified":"2022-06-05T21:40:05.22071359Z","tags":null},"/regina/why":{"title":"","content":"# Why I created a programming language\n\nTLDR: I didn't think about making a library for dynamic instantiation. I should've made a library - that is an optimal path.\n\n## Birth of 'generator or generators'\n\nI liked creating visual generators. But I didn't like spending 2 weeks to flesh out an idea and to implement unuseful\ntools like deployment to web or geometry functions.\n\n*Looking back, I realise that I wasted much time due to switching between tools: for plant generator I used C# and .NET,\nfor House generator I used Godot and for map generator Kotlin with KorGE (there I spend much time figuring out how to\nuse KorGE and writing my own geometry function).*\n\nI needed a tool to create generators. And I started thinking about it. On this stage, there was no intention on creating\na language, all the more so, I was unqualified at that time. I unofficially called this tool the 'generator of\ngenerators'.\n\n## Generator stages\nI had these project specifications (from most to least priority):\n1. It should be possible to create generators of any complexity\n2. It should be concise\n3. Non-programmers should be able to use it\n### Web tool\n\nGeometry primitives:\n\n* Segment\n* Rectangle\n* Polygon/polyline (smooth)\n* Ellipse\n* Arc (circle)\n*\n\nThree types of containers:\n\n1. Variant\n2. Recursive\n3. Container\n\n![Image](images/firstdesign.jpg)\n\n### Early stages of language development\n\n### Upgrading language","lastmodified":"2022-06-05T21:40:05.22071359Z","tags":null}}