{"/":{"title":"WaterStop","content":"\n\n[ReGIna](regina/regina)\n\n[Insta](regina/dynamic-instantiation.md)\n\n[Other notes](notes)","lastmodified":"2022-06-28T23:47:32.96675711Z","tags":null},"/100-days/100-writing-days":{"title":"100 writing days","content":"\nPreviously I did 100 reading days, but looking back, I think It was mostly about\nachieving consistency rather than improving pronunciation. Additionally, it is much easier than\nwriting, because it's consuming, not creating. This time, I'll try to write every day for 100 days,\nfollowing these rules:\n\n1. Write on paper and scan it with Google Lens. Handwriting is more beneficial for improving\n   writing ability.\n2. Write at least 10 sentences and 300 words.\n\nLinks to all articles: \n\n28 June: [Heap and Stack](Heap and Stack.md)","lastmodified":"2022-06-28T23:47:32.96675711Z","tags":null},"/100-days/Heap-and-Stack":{"title":"Basic memory management","content":"\n*Last fall, I had an interview.\nThey asked me about differences between heap and stack, how\nreferences and variables are stored.\nI was confident that I knew all this stuff.\nApparently, I was wrong.*\n\n# Commonalities\n\nBoth stack and heap use RAM.\n\n# Stack\n\nStack is a LIFO static[^1] storage that contains:\n\n* Local primitive variables\n* References to non-primitive variables\n* Method parameters\n* Sequence of method calls (hence, each thread has its own stack. Also, this is the reason why\n  infinite recursion will result in stack overflow error)\n\nWhen the method finishes its execution, a stack is emptied with one assembly command - moving\nthe pointer to stack head. Therefore, a stack returns to the state before that method's call.\n\n### Primitive variables\n\nLocal primitive variables are stored in stack. Primitive fields of an object instance are stored in\nheap.\n\n# Heap\n\nHeap is a dynamic memory structure that stores non-primitive variables. References (pointers to\nvariable address in the heap) to these variables are in the stack.\n\nUnlike stack, heap is commonly shared between threads. Consequently, one object shouldn't be\nmodified simultaneously from different threads.\n\nOut of memory error is possible for the heap too.\n\n### Garbage collector and C/C++ features\n\nSome languages (Java, C#) handle memory automatically. A component responsible for it is called\ngarbage collector. Fallback of this approach is unexpected runtime slowdowns due to garbage\ncollector managing memory.\n\nOther languages (C/C++) pass this responsibility on to programmer. In C++ every `new` keyword\nshould\nbe followed by `delete` to prevent memory leak. Additionally, it is possible to store object\ninstance on stack in C++, if variable is declared without `new`. Such local variable will\nbe popped from stack after method\nexecution. [A little bit more about C++ memory model](cpp_pointers.md).\n\n### Heap fragmentation\n\nHeap is a single block of memory. When some memory from heap is released, a chunk of unused memory\nis formed. After many iterations heap becomes a bunch of alternating fragments of used and unused\nmemory.\n\nEssentially this is an inefficient memory utilization, because overall there might be $n$\nbytes of free memory, however not all bytes can be allocated. It is possible to allocate no more\nbytes than there are in the biggest consecutive chunk of free memory.\n\n{{\u003c svg \"static/barcode.svg\" \u003e}}\n\n*After some time heap looks like a barcode (white is free memory, black is unused memory)*\n\n[^1]: some languages allow stack reallocation","lastmodified":"2022-06-28T23:47:32.96675711Z","tags":null},"/100-days/cpp_pointers":{"title":"C++ Memory model","content":"\nMemory is a two column table. First row contains **addresses**, second row contains **values**.\n```C++\nint x = 4;\n```\nWhen variable is assigned, an empty memory row cell is chosen. Variable's value is written to second column of the row.\n|Address|Value|Assigned variable (not part of a memory, just a showcase example)|\n|------|------| ---- |\n|0x1000| 4| x|\n|0x1004| 0x1000|pX|\n|0x1008|4|y|\n\n# Pointer\n```C++\nint* pX = \u0026x;\n```\nVariable declaration with a `*` after type states that it is a pointer to that type. In this case, **pX is an integer pointer**. Instead of storing value, pointer variable store memory address in their value column (second column of a memory row).\n\n`\u0026` is for extracting address from a variable. `\u0026x` means **address of variable named x**\n# Dereference\n```C++\nint y = *pX;\n```\nVariable with a preceding asterisk (`*`) referred to as a **dereference**. When used before a pointer variable, this expression will return a value in a row, to which such variable points to.","lastmodified":"2022-06-28T23:47:32.96675711Z","tags":null},"/Assignment":{"title":"","content":"# Assignment\nLeft side of the assignment before `=` is lvalue, right side is rvalue\n## Lvalue\nThere are 4 types of possible lvalues\n### Variable\n\n### Property\nSimilar to variables, however their scope is class or primitive.\n### Indexing\nChanging array's  element is possible with `arr[i] = ...`\n### Reference","lastmodified":"2022-06-28T23:47:32.96675711Z","tags":null},"/notes/eyes":{"title":"Eye focus and main eye","content":"On sketches that illustrate eye focus, it is shown that humans, when looking straight ahead, focus their vision at a point between their eyes. I came to the conclusion that it is not true, and we focus similarly to the picture on the right.\n\nI have a small experimental proof for it. Look in the mirror. What point are you looking at most of the time? For me, it is the right eye. It is the 'main' eye. If you are looking at your eye too, try switching focus to a different eye and keep it there for some time. It might feel weird, and I think that's because you are switching your main eye. If you got acquainted with that feeling, try looking around with a switched main eye. It certainly feels as if you are focusing similarly to the right picture.\n\n{{\u003c svg \"static/eyes.svg\" \u003e}}   ","lastmodified":"2022-06-28T23:47:32.96675711Z","tags":null},"/regina/dynamic-instantiation":{"title":"","content":"# Dynamic instantiation\n\nClasses can have references to other classes inside them as\nproperties. These property-classes are evaluated dynamically. Take a look at this example:\n\n```kotlin\nclass Node export rect {\n    // export = false - can deny export\n    iter = if (parent) parent.iter + 1 else 0\n\n    childNode = if (iter == 5) Nothing() else Node()\n\n    position = if (childNode is Node) \\\n    Position(childNode.position.x + 1, childNode.position.y) \\\n    else Position(0, 0)\n}\n\nfun main() {\n    Node()\n}\n```\n\nThis will create following svg:\n\n```svg\n\n\u003csvg\u003e\n    \u003crect x=\"4\" y=\"0\"/\u003e\n    \u003crect x=\"3\" y=\"0\"/\u003e\n    \u003crect x=\"2\" y=\"0\"/\u003e\n    \u003crect x=\"1\" y=\"0\"/\u003e\n    \u003crect x=\"0\" y=\"0\"/\u003e\n\u003c/svg\u003e\n```\n\nFirst algorithm creates empty Node() (we'll call it *Node0*) from main(). Then, starting from top to bottom:\n\n1. algorithm assigns **iter** of *Node0* to 0 because parent returns 0 as an equivalent of null.\n2. After that, **childNode** is assigned a new Node (*Node1*).\n3. **position** cannot be assigned because **childNode.position** is not yet assigned. Algorithm goes to\n   childNode.position, that is *Node1*.position and tries to assign it. However, childNode is required, so we go to *\n   Node1*.childNode, which needs iter.\n\n*It's not important to consider while assigning values, but it shows why there cannot be any cyclic dependencies for\nproperties*.\n\n## Implied decision\n\nAlso, it is the reason why class functions are impossible. Imagine this case:\n\n```kotlin\nclass FunctionOveruse {\n    prop = make()\n\n    fun make() {\n        FunctionOveruse()\n        return prop\n    }\n}\n```\n\nBoth lines in ```make()``` will execute forever.\n\nTo make functions as expressive as possible, it is important to allow class instantiating inside them. If\n\nWe either make internal class functions (which is purely decompositional thing) or make instantiating inside functions\npossible (and ```fun main()``` as an entry point)","lastmodified":"2022-06-28T23:47:32.96675711Z","tags":null},"/regina/regina":{"title":"ReGIna","content":"\nis a [dynamically typed](notes/typization.md) language with [syntax](syntax.md) similar to Kotlin and Python.\n\n## Core idea\n\nDifference between other languages and ReGIna is [dynamic instantiation](regina/notes/dynamic-instantiation.md). In\nshort, properties in classes will be assigned only after their dependencies are assigned, allowing recursive properties\nof same class `A` inside class `A`.\n[plant](generators/plant.json)\n\n## Advantages\n\n* **Can be embedded into web**. Regina is written in Kotlin and compiled into Javascript.\n* **Rapid generator development**. Look at [examples](#Examples) to see what can be done and how much code is required.\n* **Customizable export**.\n\n## Drawbacks\n\n* **It's slow**. It's definitely slower than Python. Yet it's designed to be fast and concise in creating generators.\n    * **There is no community**. At least not yet. Mail me at kononal@gmail.com if you created something about Regina.\n\n## Examples\n","lastmodified":"2022-06-28T23:47:32.96675711Z","tags":null},"/regina/syntax":{"title":"","content":"# Syntax\n\nReGIna's syntax is an amalgamation of kotlin and python.\n\n## Declarations\n```python\nfrom typing import Iterator\n\n# This is an example\nclass Math:\n    @staticmethod\n    def fib(n: int) -\u003e Iterator[int]:\n        \"\"\" Fibonacci series up to n \"\"\"\n        a, b = 0, 1\n        while a \u003c n:\n            yield a\n            a, b = b, a + b\n\nresult = sum(Math.fib(42))\nprint(\"The answer is {}\".format(result))\n```\n### Class\n\nClass declaration should satisfy following format:\n\n```kotlin \nclass ClassName : SuperClassName export circle {\n    ...\n}\n```\n\nwhere `: SuperClassName` and `export ...` are optional.\n\n### Object\n\n```kotlin\nobject ObjectName export circle {\n    ...\n}\n```\n\nSimilar to type, although it cannot be inherited.\n\n### Function\n\n```kotlin\nfun functionName(arg0, arg1, ...) {\n    ...\n}\n```\n\n### Property/variable assignment\n\n```kotlin\nvariableName = ...\nclassName.PropertyName = ...\n```\n\nVariables and properties are dynamic, meaning they are type independent. `a` can be String and in the next line it can\nbe Int or class instance.\n\n## References\n\nReferences are expressions of form `a.b.c`. They serve 3 purposes:\n\n1. accessing class/object properties\n2. accessing primitive/class/object and functions\n3. specifying package declarations\n4. reducing expressions\n\n### 1. Accessing properties\n\n\n# Code conventions\n\nCamel case is used.\n\nNames of [class](Syntax.md/###Class), [object](Syntax.md/###Object) start with capital.\n\nVariables, functions start with lowercase letter.","lastmodified":"2022-06-28T23:47:32.96675711Z","tags":null},"/regina/typization":{"title":"","content":"Dynamically typed languages check variable type during runtime, meaning it is more **error-prone**.On the contrary,\nstatically typed languages check variable type during compilation.\n\nOften dynamically typed languages can reassign the same variable with a different type. Also, variable declaration and\nassignment are similar for dynamic languages.\n\n```Python\n# Python\na = 2\na = \"2\" # not an error\n```\n\nOne of the clues of static typing is in variable declaration:\nusually variables have a type before a name in declaration:\n\n```C\n // C\n int a = 2;\n a = 3;\n```\n\nHowever, it is not always the case:\n\n```Kotlin\n// Kotlin\nval a = 2\n```\n\nIn Kotlin variable declaration prefix determines its mutability and type is derived from the expression on the right.\n","lastmodified":"2022-06-28T23:47:32.96675711Z","tags":null},"/regina/why":{"title":"","content":"# Why I created a programming language\n\nTLDR: I didn't think about making a library for dynamic instantiation. I should've made a library - that is an optimal path.\n\n## Birth of 'generator or generators'\n\nI liked creating visual generators. But I didn't like spending 2 weeks to flesh out an idea and to implement unuseful\ntools like deployment to web or geometry functions.\n\n*Looking back, I realise that I wasted much time due to switching between tools: for plant generator I used C# and .NET,\nfor House generator I used Godot and for map generator Kotlin with KorGE (there I spend much time figuring out how to\nuse KorGE and writing my own geometry function).*\n\nI needed a tool to create generators. And I started thinking about it. On this stage, there was no intention on creating\na language, all the more so, I was unqualified at that time. I unofficially called this tool the 'generator of\ngenerators'.\n\n## Generator stages\nI had these project specifications (from most to least priority):\n1. It should be possible to create generators of any complexity\n2. It should be concise\n3. Non-programmers should be able to use it\n### Web tool\n\nGeometry primitives:\n\n* Segment\n* Rectangle\n* Polygon/polyline (smooth)\n* Ellipse\n* Arc (circle)\n*\n\nThree types of containers:\n\n1. Variant\n2. Recursive\n3. Container\n\n![Image](images/firstdesign.jpg)\n\n### Early stages of language development\n\n### Upgrading language","lastmodified":"2022-06-28T23:47:32.96675711Z","tags":null}}